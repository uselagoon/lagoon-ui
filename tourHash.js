const crypto = require("crypto-js");
const fs = require("fs");

const propertyFromStringPath = (ob, path) => {
  // when we directly access the translation strings with a stringified accessor from tours.json
  return path.split(".").reduce((p, c) => (p && p[c]) || null, ob);
};

/* 
    Using this script before or during build, makes sure that each step in tour.json have hashes appended as their "key" properties,
    that then get used to identify content changes, which affects the visibility of these steps during the product tour.

    Removes the need for manual versioning.
*/

const tourData = JSON.parse(fs.readFileSync("tour.json", "utf-8"));
// add content hash to each step object
const routes = tourData.routes;
const isTranslated = tourData.mode === "translated";

// if tour mode is set to translated, the english version of the text will generate content hashes.
const translations = JSON.parse(
  fs.readFileSync("src/i18n/dictionary.json", "utf-8")
)?.translations?.en;

if (isTranslated && !translations) {
  throw Error("No translations provided");
}

for (let i = 0; i < routes.length; i++) {
  const routeSteps = routes[i].steps;
  for (let k = 0; k < routeSteps.length; k++) {
    const step = routeSteps[k];

    // hash will be generated by either combining translated strings or direct strings in the tour.json
    const contentToHash = isTranslated
      ? propertyFromStringPath(translations, step.content) +
        propertyFromStringPath(translations, step.title)
      : step.content + step.title;

    const stepHash = crypto.MD5(contentToHash).toString();
    routeSteps[k].key = stepHash;
  }
}
// rewrite the modified tour steps
fs.writeFileSync("tour.json", JSON.stringify(tourData, null, 2));
